var documenterSearchIndex = {"docs":
[{"location":"particle_cloud/#Particle-Cloud","page":"Particle Cloud","title":"Particle Cloud","text":"(Image: ) (Image: )\n\nUsing the same setup as detailed_look.jl or example2(), here we simulate a point cloud getting advected by the flow field. For additional documentation e.g. see : 1, 2, 3, 4","category":"section"},{"location":"particle_cloud/#1.-Import-Software","page":"Particle Cloud","title":"1. Import Software","text":"using Drifters, Statistics\n\nimport Drifters.OrdinaryDiffEq: solve, Tsit5\nimport Drifters.DataFrames: DataFrame\n\np=dirname(pathof(Drifters))\ninclude(joinpath(p,\"../examples/more/example123.jl\"));\ninclude(joinpath(p,\"../examples/more/recipes_plots.jl\"))","category":"section"},{"location":"particle_cloud/#2.-Setup-Problem","page":"Particle Cloud","title":"2. Setup Problem","text":"ğ‘ƒ,Î“=example2_setup()\n\nii1=5:5:40; ii2=5:5:25\nx=vec([x-0.5 for x in ii1, y in ii2])\ny=vec([y-0.5 for x in ii1, y in ii2])\nxy = permutedims([[x[i];y[i];1.0] for i in eachindex(x)])\n\nsolv(prob) = Drifters.ensemble_solver(prob,solver=Tsit5(),reltol=1e-6,abstol=1e-6)\ntr = DataFrame(ID=Int[], x=Float64[], y=Float64[], t=Float64[])\n\n#ğ¼ = Individuals{Float64,2}(ğŸ“Œ=xy[:,:], ğŸ”´=tr, ğŸ†”=collect(1:size(xy,2)),\n\n                    ğŸš„ = dxdt!, âˆ« = solv, ğŸ”§ = postprocess_xy, ğ‘ƒ=ğ‘ƒ);\n\nI=(position=xy,record=deepcopy(tr),velocity=dxdt!,\n   integration=solv,postprocessing=postprocess_xy,parameters=ğ‘ƒ)\nğ¼=Individuals(I)","category":"section"},{"location":"particle_cloud/#3.-Compute-Trajectories","page":"Particle Cloud","title":"3. Compute Trajectories","text":"ğ‘‡ = (0.0,2998*3600.0)\nâˆ«!(ğ¼,ğ‘‡)","category":"section"},{"location":"particle_cloud/#4.-Display-results","page":"Particle Cloud","title":"4. Display results","text":"ğ¼.ğŸ”´.lon=5000*ğ¼.ğŸ”´.x\nğ¼.ğŸ”´.lat=5000*ğ¼.ğŸ”´.y\nplt=plot_paths(ğ¼.ğŸ”´,size(xy,2),100000.0)\n\nCompare with trajectory output from MITgcm\n\n#flt_example_path = Drifters.datadeps.getdata(\"flt_example\")\n#df=read_flt(flt_example_path*\"/\",Float32)\n#ref=plot_paths(df,size(xy,2),100000.0)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"The four examples outlined below form a tutorial of sorts that complements the User Guide. They hopefully provide a useful jumping off point in order to configure Drifters.jl for new problems.\n\nOutput generated by Drifters.jl is in DataFrames.jl tabular format which comes with powerful and convenient analysis methods. They can  readily be plotted in space and time using, e.g. , Plots.jl or Makie.jl.\n\nTo rerun an example yourself, the recommended method is to copy the corresponding notebook (code) link, paste it into the Pluto.jl prompt, and click open.","category":"section"},{"location":"examples/#Simple-Two-Dimensional-Flow","page":"Examples","title":"Simple Two-Dimensional Flow","text":"notebook (html) â­ notebook (code)\n\nSimulate an ensemble of displacements (and trajectories) in a simple 2D configuration. \n\nThe FlowFields constructor readily wraps a flow field provided in the standard Array format, adds a time range, and returns a FlowFields data structure F. \n\nAll that is left to do at this stage is to define initial positions for the individuals, put them together with F into the Individuals data structure I, and call âˆ«!(I).\n\nExercises include the non-periodic domain case, statistics made easy via DataFrames.jl, and replacing the flow field with your own.","category":"section"},{"location":"examples/#Simple-Three-Dimensional-Flow","page":"Examples","title":"Simple Three-Dimensional Flow","text":"notebook (html) â­ notebook (code)\n\nSet up a three-dimensional flow field u,v,w, initialize a single particle at position ğŸ“Œ, and wrap everything up within an Individuals data structure I.\n\nI is displaced by integrating the individual velocity, moving along through space, over time T.  This is the main computation done in this package â€“ interpolating u,v,w to individual positions I.ğŸ“Œ on the fly, using I.ğŸš„, and integrating through time, using I.âˆ«.\n\nThe flow field consists of rigid body rotation, plus a convergent term, plus a sinking term in the vertical direction. This flow field generates a downward, converging spiral â€“ a idealized version of a relevant case in the Ocean.","category":"section"},{"location":"examples/#Global-Ocean-Circulation","page":"Examples","title":"Global Ocean Circulation","text":"notebook (html) â­ notebook (code)\n\nA simulation of floating particles over the Global Ocean which illustrates (1) using time variable velocity fields, (2) global connections, (3) particle re-seeding, and (4) output statistics. \n\nThe flow field is based on a data-constrained ocean model solution. The problem is configured in a way to mimic, albeit very crudely, the near-surface tranport of plastics or planktons.","category":"section"},{"location":"examples/#Three-Dimensional-Pathways","page":"Examples","title":"Three Dimensional Pathways","text":"notebook (html) â­ notebook (code)\n\nA simulation of particles that follow the three-dimensional ocean circulation. This example illustrates (1) the 3D case in a relatistic configuration, (2) tracking the advent or origin of a water patch, and (3) multifacted visualizations in 3D.\n\nThe flow field is based on a data-constrained, realistic, ocean model. The problem configuration mimics, albeit very approximately, ocean tracers / coumpounds transported by water masses.","category":"section"},{"location":"examples/#Gridded-Satellite-Data-Products","page":"Examples","title":"Gridded Satellite Data Products","text":"The Oscar data assimilative model provides daily averaged surface currents are provided on a global 0.25 x 0.25 degree grid.\nDrifters.jl is then used to compute trajectories of virtual floating parcels following Oscar flow fields.\n\nnotebook (html) â­ notebook (code)","category":"section"},{"location":"examples/#Data-Collected-in-the-Field","page":"Examples","title":"Data Collected in the Field","text":"See the User Guide section.","category":"section"},{"location":"examples/#Additional-Examples","page":"Examples","title":"Additional Examples","text":"Interactivity : notebook (html) â­ notebook (code)\nAtmosphere : notebook (html) â­ notebook (code)\nMITgcm : Particle cloud, Detailed look \nPlotting : Plots.jl, Makie.jl, PyPlot.jl","category":"section"},{"location":"examples/#Animations","page":"Examples","title":"Animations","text":"Below are animations of results generated in Global Ocean Circulation and Three Dimensional Pathways.\n\n(Image: simulated particle movie (5m))\n\n(Image: simulated particle movie (3D))","category":"section"},{"location":"workflow/#User-Guide","page":"User Guide","title":"User Guide","text":"As shown in the Examples section, the typical worflow is:\n\nset up a FlowFields data structure (F)\nset up Individuals (I) with initial position ğŸ“Œ and F\ndisplace I by\tsolve!(I,T) following I.F over T \npost-process by I.ğŸ”§ and record information in I.ğŸ”´\ngo back to step 2 and continue if needed\n\nThe data structures for steps 1 and 2 are documented below. Steps 3 and 4 normally take place as part of solve! (i.e. âˆ«!) which post-processes results, using ğŸ”§, records them in ğŸ”´, and finally updates the positions of individuals in ğŸ“Œ. Since ğŸ”´ is a DataFrame, it is easily manipulated, plotted, or saved in step 4 or after the fact.\n\nusing Drifters, CairoMakie\nP=Drifters.Gulf_of_Mexico_setup()\nF=FlowFields(u=P.u,v=P.v,period=P.T)\nI=Individuals(F,P.x0,P.y0);\n[solve!(I,P.T .+P.dT*(n-1)) for n in 1:P.nt]\nsummary(I.ğŸ”´)\n\nPlotting functions are provided in the Makie.jl extension, and operated via DriftersDataset.\n\nusing MeshArrays, GeoJSON, DataDeps\npol=MeshArrays.Dataset(\"countries_geojson1\")\n\n#prefix=\"real \"; gdf=Drifters.groupby(P.obs,:ID)\nprefix=\"virtual \"; gdf=Drifters.groupby(I.ğŸ”´,:ID)\noptions=(plot_type=\"jcon_drifters\",prefix=prefix,xlims=(-98,-78),ylims=(18,31),pol=pol)\nLoopC=DriftersDataset(  data=(gdf=gdf,), options=options )\nplot(LoopC)","category":"section"},{"location":"workflow/#Overview","page":"User Guide","title":"Overview","text":"A central goal of this package is to support scientific analysis of model simulations and observations of materials and particles within the Climate System. The package scope thus includes, for example, drifting plastics in the Ocean or chemical compounds in the Atmosphere. \n\nAs a starting point, the package supports all types of gridded model output (on Arakawa C-grids) from the MIT General Circulation Model via the MeshArrays.jl package (docs found here). \n\nBy convention, Drifters.jl expects input flow fields to be provided in a uniform fashion (see FlowFields) summarized below: \n\nnormalized to grid index units (i.e. in 1/s rather than m/s units)\npositive towards increasing indices\nusing the Arakawa C-grid, with u (resp v) staggered by -0.5 point in direction 1 (resp 2) from grid cell centers. \n\nThe Examples section documents various, simple methods to prepare and ingest such flow fields (time varying or not; in 2D or 3D) and derive individual displacements / trajectories from them. They cover simple grids often used in process studies, Global Ocean simulations normally done on more complex grids, plotting tools, and data formats. \n\nFor an overview of the examples, please refer to the example guide. The rest of this section is focused on the package's data structures and core functions.","category":"section"},{"location":"workflow/#Data-Structures","page":"User Guide","title":"Data Structures","text":"The Individuals struct contains a FlowFields struct (incl. e.g. arrays), initial positions for the individuals, and the other elements (e.g. functions) involved in âˆ«!(I,T) as documented hereafter.","category":"section"},{"location":"workflow/#Main-Functions","page":"User Guide","title":"Main Functions","text":"âˆ«!(I,T) displaces individuals I continuously over time period T according to velocity function ğŸš„, temporal integration method âˆ«, and post-processor ğŸ”§ (all embedded within I).\n\nThe velocity interpolation functions (ğŸš„) carry out the central computation of this package â€“ interpolating gridded flow fields to individual positions ğŸ“Œ. It is normally called via âˆ«! to integrate velocity ğŸš„ over a chosen time period. \n\nVelocity interpolation for several array and grid types.\nPreprocessing and postprocessing methods.\nI/O routines to read (write) results from (to) file.\n\nand other functionalities provided in src/compute.jl and src/data_wrangling.jl are further documented in the Tool Box section. Ingestion of trajectory data which have been collected by the Ocean Drifting Buoy Program (movie) is also supported.","category":"section"},{"location":"workflow/#Drifters.AbstractDriftersDataset","page":"User Guide","title":"Drifters.AbstractDriftersDataset","text":"abstract type AbstractDriftersDataset\n\nData structure used for plotting. See the docs for examples.\n\n\n\n\n\n","category":"type"},{"location":"workflow/#Drifters.FlowFields","page":"User Guide","title":"Drifters.FlowFields","text":"abstract type FlowFields\n\nData structure that provide access to flow fields (gridded as arrays) which will be  used to interpolate velocities to individual locations later on (once embedded in an Individuals struct). \n\nFollowing the C-grid convention also used in MITgcm (https://mitgcm.readthedocs.io)  flow fields are expected to be staggered as follows: grid cell i,j has its center located at i-1/2,j-1/2 while the corresponding u[i,j] (resp. `v[i,j]) is located at i-1,j-1/2 (resp. i-1/2,j-1). \n\nAlso by convention, velocity fields are expected to have been normalized to grid units (e.g. 1/s rather than m/s) before sending them to one of the supported FlowFields constructors (using either Array or MeshArray):\n\nuvArrays(u0,u1,v0,v1,T)\nuvwArrays(u0,u1,v0,v1,w0,w1,T)\nuvMeshArrays(u0,u1,v0,v1,T,update_location!)\nuvwMeshArrays(u0,u1,v0,v1,w0,w1,T,update_location!)\n\nUsing the FlowFields constructor which gets selected by the type of u0 etc. For example :\n\nF=FlowFields(u,u,v,v,0*w,1*w,[0.0,10.0])\nF=FlowFields(u,u,v,v,[0.0,10.0],func)\n\nas shown in the online documentation examples.\n\n\n\n\n\n","category":"type"},{"location":"workflow/#Drifters.FlowFields-Tuple{}","page":"User Guide","title":"Drifters.FlowFields","text":"FlowFields(;    u::Union{Array,Tuple}=[], v::Union{Array,Tuple}=[], w::Union{Array,Tuple}=[], \n                period::Union{Array,Tuple}=[])\n\nConstruct FlowFields data structure based on keywords.\n\nuC, vC, _ = SimpleFlowFields(16)\nto_C_grid!(uC,dims=1)\nto_C_grid!(uC,dims=2)\nF=FlowFields(u=uC,v=vC,period=(0,10.))\n\n\n\n\n\n","category":"method"},{"location":"workflow/#Drifters.Individuals","page":"User Guide","title":"Drifters.Individuals","text":"struct Individuals{T,N}\n\nData:           ğŸ“Œ (position),   ğŸ”´(record), ğŸ†” (ID), P (FlowFields)\nFunctions:      ğŸš„ (velocity),   âˆ« (integration), ğŸ”§(postprocessing)\nNamedTuples:    D (diagnostics),      M (metadata)\n\nThe velocity function ğŸš„ typically computes velocity at individual positions (ğŸ“Œ to start) within the  specified space-time domain by interpolating gridded variables (provided via P). Individual trajectories  are computed by integrating (âˆ«) interpolated velocities through time. Normally, integration is done by  calling âˆ«! which updates ğŸ“Œ at the end and records results in ğŸ”´ via ğŸ”§. Ancillary data, for use in  ğŸ”§ for example, can be provided in D and metadata stored in M.\n\nUnicode cheatsheet:\n\nğŸ“Œ=\\:pushpin:<tab>,          ğŸ”´=\\:red_circle:<tab>, ğŸ†”=\\:id:<tab>\nğŸš„=\\:bullettrain_side:<tab>, âˆ«=\\int<tab>,          ğŸ”§=\\:wrench:<tab>\nP=\\itP<tab>,                 D=\\itD<tab>,           M=\\itM<tab>\n\nSimple constructors that use FlowFields to choose adequate defaults:\n\nIndividuals(F::uvArrays,x,y)\nIndividuals(F::uvwArrays,x,y,z)\nIndividuals(F::uvMeshArrays,x,y,fid)\nIndividuals(F::uvwMeshArrays,x,y,z,fid)\n\nFurther customization is achievable via keyword constructors:\n\ndf=DataFrame( ID=[], x=[], y=[], z=[], t = [])\nI=Individuals{Float64,2}(ğŸ“Œ=zeros(3,10),ğŸ†”=1:10,ğŸ”´=deepcopy(df))\nI=Individuals(ğŸ“Œ=zeros(3,2),ğŸ†”=collect(1:2),ğŸ”´=deepcopy(df))\n\nOr via the plain text (or no-unicode) constructors:\n\ndf=DataFrame( ID=[], x=[], y=[], z=[], t = [])\nI=(position=zeros(3,2),ID=1:2,record=deepcopy(df))\nI=Individuals(I)\n\n\n\n\n\n","category":"type"},{"location":"workflow/#Drifters.âˆ«!","page":"User Guide","title":"Drifters.âˆ«!","text":"âˆ«!(I::Individuals,T::Tuple)\n\nDisplace simulated individuals continuously through space over time period T starting from position ğŸ“Œ. \n\nThis is typically achieved by computing the cumulative integral of velocity experienced by each individual along its trajectory (âˆ« ğŸš„ dt).\nThe current default is solve(prob,Tsit5(),reltol=1e-8,abstol=1e-8) but all solver options from the OrdinaryDiffEq.jl package are available.\nAfter this, âˆ«! is also equipped to postprocess results recorded into ğŸ”´ via the ğŸ”§ workflow, and the last step in âˆ«! consists in updating ğŸ“Œ to be ready for continuing in a subsequent call to âˆ«!.\n\n\n\n\n\nâˆ«!(I::Individuals)\n\nCall âˆ«!(I::Individuals,I.P.T)\n\n\n\n\n\n","category":"function"},{"location":"#Drifters.jl","page":"Introduction","title":"Drifters.jl","text":"Drifters.jl computes elementary point displacements over gridded domains. Inter-operability with global climate model output (on Arakawa C-grids in general) that can be represented via MeshArrays.jl (see these docs) is a central goal of Drifters.jl. \n\nThe initial example suite relies on gridded ocean transports estimated in OCCA (Forget 2010), ECCOv4 (Forget et al. 2015), and CBIOMES (Forget, 2018). For the Atmosphere, an additional example based on an idealized model simulation is provided in MITgcm.jl. \n\nTypical applications include the simulation and analysis of materials moving through atmospheric flows (e.g. dust or chemicals) or oceanic flows (e.g. plastics or planktons). An illustration of the type of observations that Drifters.jl can simulate is provided below. These data collected by Ocean Drifting Buoy can be accessed via OceanRobots.jl.\n\n(Image: Global Drifter Program data)","category":"section"},{"location":"detailed_look/#Detailed-Look","page":"Detailed Look","title":"Detailed Look","text":"(Image: ) (Image: )\n\nA more detailed look at spatial interpolation, integration through time, and I/O. For additional documentation e.g. see 1, 2, 3, 4. Here we illustrate a few things in more detail:\n\nreading velocities from file.\ngridded velocity output (Udata, Vdata)\npre-computed trajectory output (float_traj*data)\ninterpolating U,V from gridded output to individual locations\ncompared with u,v from float_traj*data\ncomputing trajectories (location v time) using OrdinaryDiffEq.jl\ncompared with x(t),y(t) from float_traj*data","category":"section"},{"location":"detailed_look/#1.-Import-Software","page":"Detailed Look","title":"1. Import Software","text":"using Drifters, MITgcm\nimport Drifters.OrdinaryDiffEq as OrdinaryDiffEq\nimport Drifters.DataFrames as DataFrames\np=dirname(pathof(Drifters))\ninclude(joinpath(p,\"../examples/more/example123.jl\"))\ninclude(joinpath(p,\"../examples/more/recipes_plots.jl\"))","category":"section"},{"location":"detailed_look/#2.-Read-Trajectory-Output","page":"Detailed Look","title":"2. Read Trajectory Output","text":"from MITgcm/pkg/flt\n\nflt_example_path = Drifters.datadeps.getdata(\"flt_example\")\nprec=Float32\ndf=read_flt(flt_example_path*\"/\",prec);\n\nplt=plot_paths(df,300,100000.0)","category":"section"},{"location":"detailed_look/#3.-Read-Gridded-Variables","page":"Detailed Look","title":"3. Read Gridded Variables","text":"using MeshArrays.jl and e.g. a NamedTyple\n\nğ‘ƒ,Î“=example2_setup();","category":"section"},{"location":"detailed_look/#4.-Visualize-Velocity-Fields","page":"Detailed Look","title":"4. Visualize Velocity Fields","text":"plt=heatmap(Î“.mskW[1,1].*ğ‘ƒ.u0,title=\"U at the start\")\nplt=heatmap(Î“.mskW[1,1].*ğ‘ƒ.u1-ğ‘ƒ.u0,title=\"U end - U start\")","category":"section"},{"location":"detailed_look/#5.-Visualize-Trajectories","page":"Detailed Look","title":"5. Visualize Trajectories","text":"(select one trajectory)\n\ntmp=df[df.ID .== 200, :]\ntmp[1:4,:]\n\nSuper-impose trajectory over velocity field (first for u ...)\n\nx=Î“.XG.f[1][:,1]\ny=Î“.YC.f[1][1,:]\nz=transpose(Î“.mskW[1].*ğ‘ƒ.u0);\n\nplt=contourf(x,y,z,c=:delta)\nplot!(tmp[:,:lon],tmp[:,:lat],c=:red,w=4,leg=false)\n\nSuper-impose trajectory over velocity field (... then for v)\n\nx=Î“.XC.f[1][:,1]\ny=Î“.YG.f[1][1,:]\nz=transpose(Î“.mskW[1].*ğ‘ƒ.v0);\n\nplt=contourf(x,y,z,c=:delta)\nplot!(tmp[:,:lon],tmp[:,:lat],c=:red,w=4,leg=false)","category":"section"},{"location":"detailed_look/#6.-Interpolate-Velocities","page":"Detailed Look","title":"6. Interpolate Velocities","text":"dx=Î“.dx\nuInit=[tmp[1,:lon];tmp[1,:lat]]./dx\nnSteps=Int32(tmp[end,:time]/3600)-2\ndu=fill(0.0,2);\n\nVisualize and compare with actual grid point values â€“ jumps on the tangential component are expected with linear scheme:\n\ntmpu=fill(0.0,100)\ntmpv=fill(0.0,100)\ntmpx=fill(0.0,100)\nfor i=1:100\n    tmpx[i]=500.0 *i./dx\n    dxdt!(du,[tmpx[i];0.499./dx],ğ‘ƒ,0.0)\n    tmpu[i]=du[1]\n    tmpv[i]=du[2]\nend\n\nplt=plot(tmpx,tmpu,label=\"u (interp)\")\nplot!(Î“.XG.f[1][1:10,1]./dx,ğ‘ƒ.u0[1:10,1],marker=:o,label=\"u (C-grid)\")\nplot!(tmpx,tmpv,label=\"v (interp)\")\nplot!(Î“.XG.f[1][1:10,1]./dx,ğ‘ƒ.v0[1:10,1],marker=:o,label=\"v (C-grid)\")\n\nAnd similarly in the other direction\n\ntmpu=fill(0.0,100)\ntmpv=fill(0.0,100)\ntmpy=fill(0.0,100)\nfor i=1:100\n    tmpy[i]=500.0 *i./dx\n    dxdt!(du,[0.499./dx;tmpy[i]],ğ‘ƒ,0.0)\n    tmpu[i]=du[1]\n    tmpv[i]=du[2]\nend\n\nplt=plot(tmpx,tmpu,label=\"u (interp)\")\nplot!(Î“.YG.f[1][1,1:10]./dx,ğ‘ƒ.u0[1,1:10],marker=:o,label=\"u (C-grid)\")\nplot!(tmpx,tmpv,label=\"v (interp)\")\nplot!(Î“.YG.f[1][1,1:10]./dx,ğ‘ƒ.v0[1,1:10],marker=:o,label=\"v (C-grid)\")\n\nCompare recomputed velocities with those from pkg/flt\n\nnSteps=2998\ntmpu=fill(0.0,nSteps); tmpv=fill(0.0,nSteps);\ntmpx=fill(0.0,nSteps); tmpy=fill(0.0,nSteps);\nrefu=fill(0.0,nSteps); refv=fill(0.0,nSteps);\nfor i=1:nSteps\n    dxy_dt_replay(du,[tmp[i,:lon],tmp[i,:lat]],tmp,tmp[i,:time])\n    refu[i]=du[1]./dx\n    refv[i]=du[2]./dx\n    dxdt!(du,[tmp[i,:lon],tmp[i,:lat]]./dx,ğ‘ƒ,Float64(tmp[i,:time]))\n    tmpu[i]=du[1]\n    tmpv[i]=du[2]\nend\n\nplt=plot(tmpu,label=\"u\")\nplot!(tmpv,label=\"v\")\nplot!(refu,label=\"u (ref)\")\nplot!(refv,label=\"v (ref)\")","category":"section"},{"location":"detailed_look/#6.-Compute-Trajectories","page":"Detailed Look","title":"6. Compute Trajectories","text":"Solve through time using OrdinaryDiffEq.jl with\n\ndxdt! is the function computing d(position)/dt\nuInit is the initial condition u @ tspan[1]\ntspan is the time interval\nğ‘ƒ are parameters for dxdt!\nTsit5 is the time-stepping scheme\nreltol and abstol are tolerance parameters\n\ntspan = (0.0,nSteps*3600.0)\n#prob = OrdinaryDiffEq.ODEProblem(dxy_dt_replay,uInit,tspan,tmp)\nprob = OrdinaryDiffEq.ODEProblem(dxdt!,uInit,tspan,ğ‘ƒ)\nsol = OrdinaryDiffEq.solve(prob,OrdinaryDiffEq.Tsit5(),reltol=1e-8,abstol=1e-8)\nsol[1:4]\n\nCompare recomputed trajectories with originals from MITgcm/pkg/flt\n\nref=transpose([tmp[1:nSteps,:lon] tmp[1:nSteps,:lat]])\nmaxLon=80*5.e3\nmaxLat=42*5.e3\n#show(size(ref))\nfor i=1:nSteps-1\n    ref[1,i+1]-ref[1,i]>maxLon/2 ? ref[1,i+1:end]-=fill(maxLon,(nSteps-i)) : nothing\n    ref[1,i+1]-ref[1,i]<-maxLon/2 ? ref[1,i+1:end]+=fill(maxLon,(nSteps-i)) : nothing\n    ref[2,i+1]-ref[2,i]>maxLat/2 ? ref[2,i+1:end]-=fill(maxLat,(nSteps-i)) : nothing\n    ref[2,i+1]-ref[2,i]<-maxLat/2 ? ref[2,i+1:end]+=fill(maxLat,(nSteps-i)) : nothing\nend\nref=ref./dx;\n\nplt=plot(sol[1,:],sol[2,:],linewidth=5,title=\"Using Recomputed Velocities\",\n     xaxis=\"lon\",yaxis=\"lat\",label=\"Julia Solution\") # legend=false\nplot!(ref[1,:],ref[2,:],lw=3,ls=:dash,label=\"MITgcm Solution\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"API/#Velocity-Interpolation","page":"Tool Box","title":"Velocity Interpolation","text":"The dxdt! etc functions compute the tracked individual velocity. ","category":"section"},{"location":"API/#Setup-And-Postprocessing","page":"Tool Box","title":"Setup And Postprocessing","text":"Convenience functions to initialize a simulation and post-process the output are provided. \n\nBasic geography support:","category":"section"},{"location":"API/#Toy-Problems","page":"Tool Box","title":"Toy Problems","text":"These are used to demonstrate and test the package functionalities:","category":"section"},{"location":"API/#Read-External-Files","page":"Tool Box","title":"Read External Files","text":"Trajectory simulated by the MITgcm or observed by the global drifter program can be read from file using, respectively .read_flt (from .jl) or  OceanRobots.drifters_hourly_read (from OceanRobots.jl).","category":"section"},{"location":"API/#Drifters.dxdt!","page":"Tool Box","title":"Drifters.dxdt!","text":"dxdt!(du,u,p::uvwMeshArrays,tim)\n\nInterpolate velocity from gridded fields (3D; with halos) to position u (x,y,z,fIndex) to compute the derivative of position v time  du_dt.\n\nExtended help\n\nusing Drifters\nu,v,w,pos,func=vortex_flow_field(format=:MeshArray)\nF=FlowFields(u,u,v,v,0*w,1*w,[0,3*pi],func)\nI=Individuals(F,pos...)\nâˆ«!(I)\n\nusing CairoMakie\nJ=DriftersDataset( data=(I=I,), options=(plot_type=:simple_plot2,) )\nf=plot(J)\n\nref=[9.35, 7.94, 1.29, 1.0] #hide\nprod(isapprox.(I.ğŸ“Œ,ref,atol=1.0)) # hide\n\n\n\n\n\ndxdt!(du,u,p::uvMeshArrays,tim)\n\nInterpolate velocity from gridded fields (2D; with halos) to position u (x,y,fIndex) to compute the derivative of position v time  du_dt.\n\nExtended help\n\nusing Drifters\nu,v,w,pos,func=random_flow_field(format=:MeshArray)\nF=FlowFields(u,u,v,v,[0,1.0],func)\nI=Individuals(F,pos...)\nâˆ«!(I)\n\nisa(I.ğŸ“Œ,Vector)\n\n\n\n\n\ndxdt!(du,u,P::uvwArrays,tim)\n\nInterpolate velocity from gridded fields (3D; NO halos) to position u (x,y,z) to compute the derivative of position v time  du_dt.\n\nExtended help\n\nusing Drifters\nu,v,w,pos=vortex_flow_field(format=:Array)\nF=FlowFields(u,u,v,v,0*w,1*w,[0,3*pi])\nI=Individuals(F,pos...)\nâˆ«!(I)\n\nref=[9.35, 7.93, 1.28] # hide\nprod(isapprox.(I.ğŸ“Œ,ref,atol=1.0)) # hide\n\n\n\n\n\ndxdt!(du,u,P::uvArrays,tim)\n\nInterpolate velocity from gridded fields (2D; NO halos) to position u (x,y) to compute the derivative of position v time  du_dt.\n\nExtended help\n\nusing Drifters\nu,v,w,pos=random_flow_field(format=:Array)\nF=FlowFields(u,u,v,v,[0,1.0])\nI=Individuals(F,pos...)\nâˆ«!(I)\n\nisa(I.ğŸ“Œ,Vector)\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.dxy_dt_replay","page":"Tool Box","title":"Drifters.dxy_dt_replay","text":"dxy_dt_replay(du,u,p::DataFrame,t)\n\nInterpolate velocity from MITgcm float_trajectories output and return position increment du.\n\nExtended help\n\nusing Drifters\np=dirname(pathof(Drifters))\ninclude(joinpath(p,\"../examples/more/detailed_look.jl\"))\nprod(isapprox.(sol[:,end],ref[:,end],atol=1.0))\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.dxy_dt_CyclicArray","page":"Tool Box","title":"Drifters.dxy_dt_CyclicArray","text":"dxy_dt_CyclicArray(du,u,P::NamedTuple,tim)\n\nNearest neighbor (?) velocity from gridded fields (2D; NO halos but not needed when CyclicArrays is used to extend valid indice ranges).\n\nExtended help\n\nnotes: spatial interpolation & temporal interpolation are lacking\n\nusing Drifters\np=dirname(pathof(Drifters))\ninclude(joinpath(p,\"../examples/more/example_CyclicArray.jl\"))\n(x,y)=cyclicarray_example()\n\nref=[330.5 290.5]\nprod(isapprox.([x[end] y[end]],ref,atol=1.0))\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.postprocess_xy","page":"Tool Box","title":"Drifters.postprocess_xy","text":"postprocess_xy(sol,P::FlowFields,D::NamedTuple; id=missing, T=missing)\n\nCopy sol to a DataFrame & map position to x,y coordinates, and define time axis for a simple doubly periodic domain\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.postprocess_MeshArray","page":"Tool Box","title":"Drifters.postprocess_MeshArray","text":"postprocess_MeshArray(sol,P::FlowFields,D::NamedTuple; id=missing, T=missing)\n\nCopy sol to a DataFrame & map position to lon,lat coordinates using \"exchanged\" D.XC, D.YC via add_lonlat!\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.add_lonlat!","page":"Tool Box","title":"Drifters.add_lonlat!","text":"add_lonlat!(df::DataFrame,XC,YC)\n\nAdd lon & lat to dataframe using \"exchanged\" XC, YC\n\n\n\n\n\nadd_lonlat!(df::DataFrame,XC,YC,func::Function)\n\nAdd lon & lat to dataframe using \"exchanged\" XC, YC after updating  subdomain indices (via func) if needed (MeshArrays.locationisout)\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.gcdist","page":"Tool Box","title":"Drifters.gcdist","text":"gcdist(I::Individuals)\n\nGreat circle distance (gcd in radians) between final and initial positions.\n\n\n\n\n\ngcdist(lo1,lo2,la1,la2)\n\nGreat circle distance (gcd in radians) between two positions.\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.diff","page":"Tool Box","title":"Base.diff","text":"Base.diff(I::Individuals)\n\nDifference in grid unit coordinates (dx,dy) between final and initial positions.\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.stproj","page":"Tool Box","title":"Drifters.stproj","text":"stproj(XC,YC;XC0=0.0,YC0=90.0)\n\nApply to XC,YC (longitude, latitude) the stereographic projection which would put XC0,YC0 (longitude, latitude) at x,y=0,0\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.stproj_inv","page":"Tool Box","title":"Drifters.stproj_inv","text":"stproj_inv(xx,yy;XC0=0.0,YC0=90.0)\n\nApply to xx,yy (stereographic projection coordinates) the reverse  of the stereographic projection which puts XC0,YC0 (longitude,  latitude) at x,y=0,0\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.randn_lonlat","page":"Tool Box","title":"Drifters.randn_lonlat","text":"randn_lonlat(nn=1,seed=missing)\n\nRandomly distributed longitude, latitude positions on the sphere.\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.interp_to_lonlat","page":"Tool Box","title":"Drifters.interp_to_lonlat","text":"interp_to_lonlat(X::MeshArray,Î“::NamedTuple,lon,lat)\n\nUse MeshArrays.Interpolate() to interpolate to arbitrary positions (e.g., a regular grid for plotting).\n\nExtended help\n\nusing Drifters\nimport Drifters: MeshArrays\nÎ³=MeshArrays.GridSpec(ID=:LLC90)\nÎ“=MeshArrays.GridLoad(Î³,option=\"full\")\n\nlon=[i for i=20.:20.0:380., j=-70.:10.0:70.]\nlat=[j for i=20.:20.0:380., j=-70.:10.0:70.]\ntmp1=interp_to_lonlat(Î“.Depth,Î“,lon,lat)\n\n(f,i,j,w,_,_,_)=MeshArrays.InterpolationFactors(Î“,vec(lon),vec(lat))\nIntFac=(lon=lon,lat=lat,f=f,i=i,j=j,w=w)\ntmp1=interp_to_lonlat(Î“.Depth,IntFac)\n    \nprod(isapprox(maximum(tmp1),5896.,atol=1.0))\n\n# output\n\ntrue\n\n\n\n\n\ninterp_to_lonlat(X::MeshArray,IntFac::NamedTuple)\n\nUse MeshArrays.Interpolate() to interpolate to arbitrary positions (e.g., a regular grid for plotting).\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.interp_to_xy","page":"Tool Box","title":"Drifters.interp_to_xy","text":"interp_to_xy(df::DataFrame,Zin::MeshArray)\n\nInterpolate \"exchanged\" / \"hallo-included\" Zin to df[!,:x], df[!,:y] on df[!,:fid]\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.nearest_to_xy","page":"Tool Box","title":"Drifters.nearest_to_xy","text":"nearest_to_xy(Î±::MeshArray,x,y,f)\n\nValue of Î± at eachindex of the grid cell center nearest to x,y on subdomain array / facet f\n\n\n\n\n\nnearest_to_xy(Î±::Array,x,y)\n\nValue of Î± at eachindex of the grid cell center nearest to x,y\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.random_flow_field","page":"Tool Box","title":"Drifters.random_flow_field","text":"random_flow_field(;component=:Rotational,np=20,format=:Array)\n\nGenerate random flow fields on a grid of np x nq points for use in simple examples.\n\nThe :Rotational component option is most similar to what is done  in the standard example.\n\nThe :Divergent component option generates a purely divergent flow field instead.\n\n(U,V,Î¦)=random_flow_field(component=:Rotational)\nF=convert_to_FlowFields(U,V,10.0)\nI=Individuals(F,x,y,fill(1,length(x)))\n\n\n\n\n\n","category":"function"},{"location":"API/#Drifters.vortex_flow_field","page":"Tool Box","title":"Drifters.vortex_flow_field","text":"vortex_flow_field(; np=12,nz=4,format=:Array)\n\nSet up an idealized flow field which consists of  rigid body rotation,  plus a convergent term, plus a sinking term.\n\nu,v,w,func=vortex_flow_field(format=:MeshArray)\n\n\n\n\n\n","category":"function"}]
}
